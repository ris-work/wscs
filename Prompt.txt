I need to write a program in C#. No "Program" class, script-style, one-file only- terse, only comment where things are not obvious, be modular but they all should be functions. There should be two sockets, named EXENAME.ipc.sock and EXENAME.debug.sock, and if they are not found, create them. The program creates EXENAME.ipc.sock and daemonizes itself. It unlinks if the socket is inactive and creates ones. It unlinks on exit. It processes the arguments and runs properly of the socket is created by us at this instance, otherwise it requests the EXENAME.ipc.sock (JSON format) to tell what to do. I want a websockify replacement, and the reverse, but for simplicity, all work only through UNIX sockets. Each connection to the "source" socket opens and communicates to the "destination". The IPC should have the fields, destination name, source name, source type. The destination type is ALWAYS the opposite of the source type. The type could be TCP or WS. Make it AoT serializable. Terse classes. The program is launched with the following format: wsProc = Process.Start(new ProcessStartInfo("websockify", $"--unix-listen=ws-{wsPort} --unix-target={ShouldConnectToUSock}") { UseShellExecute = false })!; Debug socket is the Log() function that prints the real-time log to all the connected clients. Also make a EXENAME.stats.sock that prints stats, all of the List<Sessions>, both alive and dead and quits the connection to the sock. Thank you. Give me only the cs file. It should timeout sessions on inactivityread from env INACTIVITY_TIMEOUT ms, default to 120000 ms. Use builtins, including WebSockets, Kestrel, etc., DO NOT write any manual protocol logic like HTTP 200\r\n. Wrap them in proper socket types. Allow sourcetype to be specifiable in arguments. We are replacing websockify, we ARE the websockify so you should write all stream forwarding operations/tasks. The goal is to replace websockify's one process per port model with a more efficient async.
